# Android 메모리 관리
- **가비지 컬렉션**메커니즘을 통해 메모리 관리
   - 사용되지 않는 메모리를 자동으로 회수
   - 더 이상 참조되지 않는 객체 정리
- Android는 메모리가 부족할 때 "포그라운드 애플리케이션을 우선적으로 처리"
   - 백그라운드 프로세스를 종료하기 위해 low-memory killer 사용
## Android 메모리 누수의 원인
- 더 이상 필요하지 않은 객체에 대한 참조를 유지하여 가비지 컬렉터가 메모리를 회수하지 못할 때 발생
   - 부적절한 생명주기 관리
   - 정적 참조
   - Context에 대한 장기 참조 등
## 모범사례
### 생명주기를 인지하는 컴포넌트 사용
- ViewModel, **collectAsStateWithLifecycle** 등 생명주기를 인지하는 컴포넌트를 활용하면 리소스가 적절히 해제됨
```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            val state = viewModel.collectAsStateWithLifeclycle()
            MainScreen(state)
        }
    }
}
```
   - [collectAsState vs collectAsStateWithLifecycle](https://medium.com/hongbeomi-dev/jetpack-compose%EC%97%90%EC%84%9C-flow%EB%A5%BC-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-a394a679909b)
      - collectAsState: 안드로이드 생명주기와 관련없이 다른 플랫폼 개발을 위해 사용
      - collectAsStateWithLifecycle: 안드로이드 생명주기에 맞춰 데이터를 collect 하는 함수 - Android 개발에 적절
### Context에 대한 오랜 참조 피하기
- 정적 필드나 싱클톤과 같은 오래 지속되는 객체에서 Activity 또는 Context에 대한 참조유지 X
   - 필요하다면 `ApplicationContext`를 사용하는게 좋음
### 리스너 및 콜백 등록 올바르게 해제하기
- onPause() 또는 onStop()에서 리스너, 관찰자 또는 콜백등을 올바르게 해제해야함
   - 앱이 백그라운드에 있을 때 참조를 유지하지 않음
### 중요하지 않은 객체는 WeakReference 사용하기
```kotlin
import java.lang.ref.WeakReference

fun main() {
    var printer: Printer? = Printer()
    val weak: WeakReference<Printer> = WeakReference(printer)

    println(weak.get())

    printer = null
    println(weak.get())
}

class Printer() {
    fun printer() {
        println("printing $this")
    }
}
```
- 가비지 컬렉터가 해당 객체를 언제든지 회수할 수 있음
### 누수 감지 툴 사용
- LeakCanary, MemoryProfiler를 사용하여 어떤 객체가 메모리 누수를 일으키는지 등을 확인 가능
   - LeakCanary : Square사에서 만든 오픈소스 라이브러리

   ```
   D LeakCanary: Watching instance of com.example.leakcanary.MainActivity
  (Activity received Activity#onDestroy() callback) 
   ... 5 seconds later ...
  D LeakCanary: Scheduling check for retained objects because found new object
  retained
  ```
### View에 대한 정적 참조 피하기
  ```kotlin
  object Views {

    val customView: View? = null // Activity 컨텍스트에 대한 참조 유지, 메모리 누수 유발 가능
  }
  ```
### 리소스 닫기
  - 파일 스트림, 데이터베이스 연결과 같은 리소스는 더 이상 필요하지 않을 때 명시적으로 해제
### Fragment, Activity 현명하게 사용
- onDestroyView(), onDetatch()에서 Fragment 참조 정리