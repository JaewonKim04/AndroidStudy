# Fragment 생명주기
## onAttach()
- fragment가 부모 Activity와 연결될 때 호출
## onCreate()
- fragment를 초기화하기 위해 호출
- UI는 생성되지 않은 상태
## onCreateView()
- UI가 처음으로 그려질 때 호출
- 레이아웃을 인플레이션 하는 곳
```kotlin
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return super.onCreateView(inflater, container, savedInstanceState)
    }
```
## onViewStateRestored()
- 뷰 계층이 생성되고 저장된 상태가 뷰에 복원된 후 호출
## onViewCreated()
- 뷰가 생성된 후 호출
- 주로 상호작용 처리에 필요한 로직 설정
## onStart()
- 사용자에게 fragment가 보이는 상태
- 아직 포그라운드에 있지는 않음
## onResume()
- 완전히 활성 상태
- 상호작용 가능
## onPause()
- 포그라운드에 없지만 여전히 보이는 상태
- 포커스를 잃기 직전
## onStop()
- 더이상 보이지 않음
- 화면 밖에 있는 동안 지속할 필요 없는 작업 중지
## onSaveInstanceState()
- 소면되기 전, 관련 데이터를 저장하는 함수
## onDestroyView()
- 뷰 계층이 제거될 때 호출
- 뷰와 관련된 리소스 해제 필요(어댑터를 지우거나 참조를 null로 만드는 등)
## onDestroy()
- fragment 자체가 소멸될 때. 호출
- 모든 리소스 필요
- 여전히 부모 activity에는 연결되어있음
## onDetach()
- 부모 activity에서 분리
- 마지막 콜백

# fragmentManager와 childFragmentManager의 차이
## fragmentManager
- Activity 수준에서 작동
- Activity에 연결된 Fragment 관리
- activity의 생명주기 따름
## childFragmentManager
- Fragment 내에서 작동
- 부모 Fragment 내에 중첩된 Fragment 관리
- 부모 Fragment의 생명주기 따름

# viewLifecycleOwner 인스턴스
- Fragment의 뷰 계층은 Fragment 생명주기와 별도의 그것을 가짐
- UI 계층과 관련된 생명주기를 효과적으로 관리하는데 도움
```kotlin
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        viewModel.data.observe(viewLifecycleOwner) { data -> // view의 생명주기 동안 observe
            // Update UI with data
        }
    }
```
- onCreateView ~ onDestroyView 까지의 생명주기
- 뷰 계층 생명주기에 바인딩하여 잠재적인 메모리 누수등의 문제 방지
- Fragment 생명주기보다 짧음
