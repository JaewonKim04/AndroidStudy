# Context란?
- 애플리케이션의 **환경 또는 상태**
- 리소스 및 클래스에 대한 접근 제공
    - Activity 실행, assets&res접근, 레이아웃 인플레이션과 같은 작업에 필수
        - assets: res와 비슷한 리소스 파일
## Application Context
- 애플리케이션 라이프 사이클과 연결
- 전역적이고 오래 지속되는 Context가 필요할 때 사용
### 사용사례
- 앱 전체 리소스 접근하는 경우 (SharedPreference, 데이터베이스)
- 앱 생명주기동안 유지되어야하는 BroadcastReceiver 등록, 라이브러리, 컴포넌트 초기화
## Activity Context
- Activity 라이프 사이클과 연결
### 사용사례
```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        this.startActivity(...)
    }
}
```
- 다른 Activity 시작
- 레이아웃 인플레이션
## Service Context
- Service의 생명주기와 연결
- 주로 네트워크 작업 수행이나 음악 재생같은 작업에 사용
## Broadcast Context
- BroadcastReceiver가 호출될 때 제공
- 생명주기가 짧기 때문에 (Broadcast에 응답할 때) 장기적인 태스크를 수행하면 안됨

# Context의 일반적인 사용사례
1. 리소스 접근 : getString(), getDrawable()과 같은 메서드를 사용하여 리소스에 대한 접근 제공
```kotlin
resources.getDrawable(R.drawable.ic_launcher_foreground, null)

// AppCompatActivity
public Resources getResources() {
        if (mResources == null && VectorEnabledTintResources.shouldBeUsed()) {
            mResources = new VectorEnabledTintResources(this, super.getResources());
        }
        return mResources == null ? super.getResources() : mResources;
    }
```
2. 레이아웃 인플레이션 : XML 레이아웃을 뷰로 인플레이션하는 데 사용
3. 액티비티 및 서비스 시작 : Activity와 Service를 시작하려면 Context 필요
```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        this.startService(...)
    }
}
```
4. 시스템 서비스 접근 : getSystemService()를 통해 ClipboardManager 또는 ConnectivityManager와 같은 시스템 접근 제공
```kotlin
val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
````
5. 데이터 베이스 및 SharedPreference 접근
```kotlin
val sharedPref = activity?.getSharedPreferences(
        getString(R.string.preference_file_key), Context.MODE_PRIVATE)
```
# 사용시 주의할 점
- 부적절하게 사용했을 때 생길 수 있는 문제
    - 메모리 누수
    - 크래시
    - 비효율적인 리소스 처리
- 문제1 : Activity, Fragment Context의 참조를 생명주기보다 오래 지속하는 것
```kotlin
object Singleton {
    var context: Context? = null // 메모리 누수 유발
}
```


```kotlin
object Singleton {
    lateinit var appicationContext: Context // 오래 지속이 필요하다면 application context 사용
}
```
- 문제2 : UI 관련 작업에 applicationContext 사용
```kotlin
val dialog = AlertDialog.Builder(context.applicationContext) // 테마에 대한 리소스 정보 없음. activity 등의 context 사용 필요
```
- 문제3 : 컴포넌트가 소멸된 후 Context 사용
    - 크래시나 예상치못한 동작 발생 가능
```kotlin
val button = Button(activity)
activity.finish()
```
- 문제 4: 백그라운드 스레드에서 Context 사용
    - Context는 메인 스레드용. 크래시나 스레딩 관련 문제 발생 가능
# ContextWrapper
- context의 특정 동작을 개선시키거나 재정의할 때 사용
## 사용사례
- 커스텀 컨텍스트: 앱 전체 다른 테마 적용, 특수한 방식의 리소스 처리 방식등을 처리할 때 커스텀 Context를 생성하기 위해 사용
- 동적 리소스 처리: 리소스를 동적으로 제공하거나 수정하기 위해 사용
- 의존성 주입: Dagger나 Hilt와 같은 라이브러리에서 의존성 주입을 위해 ContextWrapper 생성, 해당 ContextWrapper를 Context 타입으로 제공
## 이점
- 재사용성: 커스텀 로직을 여러 컴포넌트에서 사용가능
- 캡슐화&호환성: 원본 Context 구현을 변경하지 않고 동작 개선 가능

# Activity의 this와 baseContext
## this
- Activity와의 상호작용이 가능한 API 호출 가능(생명주기 관리 및 UI 개발)
    - 다른 Activity 실행이나 Dialog를 띄울 때 사용 가능
## baseContext
- 원본 Context를 참조해야할 때 (Activity도 ContextWrapper를 상속하고 있기 때문)
    - 직접 사용하는 경우는 드물지만 ContextWrapper를 커스텀 할 때 등에 사용
## 차이점
- 범위
    - this: activity의 생명주기
    - baseContext: Activity가 구축된 저수준의 context
- 사용법
    - this: 다른 Activity 시작과 같은 UI작업에 사용
    - baseContext: 커스텀 ContextWrapper를 구현시 핵심 구현체와 상호작용할 때
- 계층
    - baseContext도 Activity 기반 context이기 때문에 Activity가 ContextWrapper로서 제공하는 API 우회적인 접근 가능
```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        baseContext.startActivity(...)
    }
}
```