# MVVM
* Model-View-ViewModel
* 각각의 역활을 분리(가독성,재사용성 높음)
* 액티비티를 가볍게 만들어줌
* 액티비티의 종속성을 낮춰 __테스트,유지보수를 쉽게__ 해줌
* 흐름: 사용자가 View 데이터를 요청함-> __view가 viewModel을 관찰하고 있음__ -> model 에서 데이터를 변경함->view가 바뀜
## 장점
1. __뷰가 데이터를 실시간으로 관찰함__:LiveData(Observable)패턴을 이용하기 때문에 자동으로 UI를 갱신함->__직접 뷰를 바꾸어주는 번거로움__ 도 없으며 __데이터와 불일치할 확률이 줄어듦__
2. __생명주기로부터 안전__: 액티비티/프래그먼트의 생명주기를 따르지 않음(뷰모델을 통한 데이터 참조)-> 화면전환이 되도 데이터는 그대로 있음&뷰가 활성화되어있을때만 작동하기때문에 메모리 사용을 줄일수 있음
3. __역할분리&모듈화__:UI,비즈니스 로직,데이터베이스가 기능별로 모듈화 되어있어서 역할 별로 정리가 깔끔함->유닛 테스트가 용이해짐
## 단점
1. 추가로 만들어야하는 __클래스가 많음__
2. 많은 클래스들을 연결시켜줘야함
-> 시간이 많이 걸림
## View
* UI를 담당하는 액티비티나 프래그먼트
* 화면에 무엇을 그릴지 결정
* 사용자와 상호작용함
* 대체로 데이터의 변화를 감지하기 위한 __옵저버__ 를 가지고 있다.
## ViewModel
* UI를 위한 데이터를 갖고있음
* 구성이 변경되어도 그대로 남아있음(화면회전,언어 변경 등)
* 뷰와 분리되어있어 액티비티가 Destroy되어도 데이터를 여전히 가지고 있음
## LiveData
* 관찰이 가능한(Observable)데이터 홀더 클래스
* 뷰에서 뷰모델의 라이브데이터를 관찰하게 되면 데이터가 변경될 때 내부적으로 자동으로 알려줌
* 액티비티나 프래그먼트의 생명 주기를 인지함-> 액티비티가 화면 위에 활성화되어 있을 때만 동작함(메모리 릭의 발생을 줄임)
## Repository
* 뷰모델과 상호작용하기 위해 잘 정리된 데이터 API를 들고있는 클래스
* 앱에 필요한 데이터를 가져옴(내장 데이터베이스나 외부 웹 서버 등)
## Room
* SQLite 데이터베이스를 편하게 사용하게 해주는 라이브러리