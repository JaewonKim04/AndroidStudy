# 리액티브 연산자
* 부수 효과가 없는 __순수 함수__
* 연산자 분류

|연산자|설명|
|---------|-------|
|생성(Creating) 연산자|데이터의 흐름을 만들어 내는 함수. (create(),just(),fromArray()등). **RxJava 프로그래밍은 생선연산자에서 시작함**|
|변환(Transforming) 연산자|입력을 받아서 출력 결과를 내는 함수(map(),flatMap()등)|
|필터(Filter) 연산자|입력 데이터 중에 원하는 데이터만 걸러냄(filter(),first(),take()등)|
|합성(Combining) 연산자|여러 Observable을 조합하는 역할|
|오류 처리(Error Handling) 연산자|onError(),onErrorResumeNext(),retry()등|
|유틸리티(Utility) 연산자| 비동기 프로그래밍을 지원(subscribeOn(),observeOn()등)|
|조건(Conditional) 연산자|Observable의 흐름을 제어하는 역할
|수학과 집합형 연산자|수학 함수와 연관 있는 연산자|
|배압(Back pressure) 연산자|배압 이슈에 대응하는 연산자|

## RxJava의 제네릭 함수역 인터페이스

|인터페이스 이름|포함 메서드|설명|
|-----|-----|-----|
|Predicate<T>|boolean test(T t)|t 값을 받아서 참이나 거짓을 반환|
|Consumer<T>|void accept(T t)|t 값을 받아서 처리(반환값X)|
|Fuction<T,R>|R apply(T t)|t 값을 받아서 결과를 반환|

## map()함수
* 입력값을 **어떤 함수에 넣어서** 원하는 값으로 변환하는 함수
    * 입력 데이터와 그것을 변환해줄 함수를 이어주는 중개업자
    * 예시
        ```java
        String[] balls = {"1","2","3","5"};
        Observable<String> source = Observable.fromArray(balls)
         .map(ball -> "No."+ball)
        source.subscribe(Log::i);
        ```
    * Function인터페익스를 적용한 map() 함수
        ```java
        Function<String,String> getDiamond = ball -> "No."+ball;

        String[] balls = {"1", "2", "3", "5"};
        Observable<String> source = Observable.fromArray(balls)
            .map(getDiamond);
            source.subscribe(Log::i);
        ```
        실행결과
        ```
        No.1
        No.2
        No,3
        No.5
        ```
    


참고도서: [RxJava프로그래밍-유동환,박정준 지음](https://book.naver.com/bookdb/book_detail.nhn?bid=12495967)    